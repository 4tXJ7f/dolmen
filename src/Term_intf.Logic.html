<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<link rel="stylesheet" href="style.css" type="text/css">
<meta content="text/html; charset=iso-8859-1" http-equiv="Content-Type">
<link rel="Start" href="index.html">
<link rel="Up" href="Term_intf.html">
<link title="Index of types" rel=Appendix href="index_types.html">
<link title="Index of exceptions" rel=Appendix href="index_exceptions.html">
<link title="Index of values" rel=Appendix href="index_values.html">
<link title="Index of modules" rel=Appendix href="index_modules.html">
<link title="Index of module types" rel=Appendix href="index_module_types.html">
<link title="Term" rel="Chapter" href="Term.html">
<link title="Statement" rel="Chapter" href="Statement.html">
<link title="ParseLocation" rel="Chapter" href="ParseLocation.html">
<link title="Base_intf" rel="Chapter" href="Base_intf.html">
<link title="Term_intf" rel="Chapter" href="Term_intf.html">
<link title="Stmt_intf" rel="Chapter" href="Stmt_intf.html">
<link title="Lex_intf" rel="Chapter" href="Lex_intf.html">
<link title="Parse_intf" rel="Chapter" href="Parse_intf.html">
<link title="Location_intf" rel="Chapter" href="Location_intf.html">
<link title="Language_intf" rel="Chapter" href="Language_intf.html">
<link title="Dimacs" rel="Chapter" href="Dimacs.html">
<link title="Ast_dimacs" rel="Chapter" href="Ast_dimacs.html">
<link title="Smtlib" rel="Chapter" href="Smtlib.html">
<link title="Ast_smtlib" rel="Chapter" href="Ast_smtlib.html">
<link title="Zf" rel="Chapter" href="Zf.html">
<link title="Ast_zf" rel="Chapter" href="Ast_zf.html">
<link title="Tptp" rel="Chapter" href="Tptp.html">
<link title="Ast_tptp" rel="Chapter" href="Ast_tptp.html">
<link title="Logic" rel="Chapter" href="Logic.html"><link title="Predefined terms" rel="Section" href="#3_Predefinedterms">
<link title="Terms leaf constructors" rel="Section" href="#3_Termsleafconstructors">
<link title="Term constructors" rel="Section" href="#3_Termconstructors">
<link title="Type constructors" rel="Section" href="#3_Typeconstructors">
<link title="Special constructions" rel="Section" href="#3_Specialconstructions">
<title>Term_intf.Logic</title>
</head>
<body>
<div class="navbar">&nbsp;<a class="up" href="Term_intf.html" title="Term_intf">Up</a>
&nbsp;</div>
<h1>Module type <a href="type_Term_intf.Logic.html">Term_intf.Logic</a></h1>

<pre><span class="keyword">module type</span> Logic = <code class="code">sig</code> <a href="Term_intf.Logic.html">..</a> <code class="code">end</code></pre><hr width="100%">
<br>
Signature used by the Logic classes, which parse languages
      such as tptp, smtlib, etc...
      Mainly used to parse first-order terms, it is also used to
      parse tptp's THF language, which uses higher order terms, so
      some first-order constructs such as conjunction, equality, etc...
      also need to be represented by standalone terms.<br>

<pre><span class="keyword">include</span> <a href="Base_intf.S.html">Base_intf.S</a></pre>
<br>
<h3 id="3_Predefinedterms">Predefined terms</h3><br>

<pre><span id="VALeq_t"><span class="keyword">val</span> eq_t</span> : <code class="type">t</code></pre>
<pre><span id="VALneq_t"><span class="keyword">val</span> neq_t</span> : <code class="type">t</code></pre><div class="info ">
The terms representing equality and diequality, respectively.<br>
</div>

<pre><span id="VALwildcard"><span class="keyword">val</span> wildcard</span> : <code class="type">t</code></pre><div class="info ">
The wildcard term, usually used in place of type arguments
      to explicit polymorphic functions to not explicit types that
      can be inferred by the type-checker.<br>
</div>

<pre><span id="VALtType"><span class="keyword">val</span> tType</span> : <code class="type">t</code></pre><div class="info ">
The type of types, defined as specific token by the Zipperposition format;
      in other languages, will be represented as a constant (the "$tType" constant
      in tptp for instance). Used to define new types, or quantify type variables
      in languages that support polymorphism.<br>
</div>

<pre><span id="VALprop"><span class="keyword">val</span> prop</span> : <code class="type">t</code></pre><div class="info ">
The type of propositions. Also defined as a lexical token by the Zipperposition
      format. Will be defined as a constant in most other languages (for instance,
      "$o" in tptp).<br>
</div>

<pre><span id="VALtrue_"><span class="keyword">val</span> true_</span> : <code class="type">t</code></pre>
<pre><span id="VALfalse_"><span class="keyword">val</span> false_</span> : <code class="type">t</code></pre><div class="info ">
The constants for the true and fals propositional constants. Again defined
      as lexical token in the Zipperposition format, while treated as a constant
      in other languages ("$true" in tptp).<br>
</div>

<pre><span id="VALnot_t"><span class="keyword">val</span> not_t</span> : <code class="type">t</code></pre>
<pre><span id="VALor_t"><span class="keyword">val</span> or_t</span> : <code class="type">t</code></pre>
<pre><span id="VALand_t"><span class="keyword">val</span> and_t</span> : <code class="type">t</code></pre>
<pre><span id="VALxor_t"><span class="keyword">val</span> xor_t</span> : <code class="type">t</code></pre>
<pre><span id="VALnor_t"><span class="keyword">val</span> nor_t</span> : <code class="type">t</code></pre>
<pre><span id="VALnand_t"><span class="keyword">val</span> nand_t</span> : <code class="type">t</code></pre>
<pre><span id="VALequiv_t"><span class="keyword">val</span> equiv_t</span> : <code class="type">t</code></pre>
<pre><span id="VALimplied_t"><span class="keyword">val</span> implied_t</span> : <code class="type">t</code></pre>
<pre><span id="VALimplies_t"><span class="keyword">val</span> implies_t</span> : <code class="type">t</code></pre><div class="info ">
Standard logical connectives viewed as terms. <code class="code">implies_t</code> is usual
      right implication, i.e <code class="code">apply implies_t [p; q] </code> is "p imples q",
      while <code class="code">apply impled_t [p; q ]</code> means "p is implied by q" or
      "q implies p".<br>
</div>

<pre><span id="VALdata_t"><span class="keyword">val</span> data_t</span> : <code class="type">t</code></pre><div class="info ">
Term without semantic meaning, used for creating "data" terms.
      Used in tptp's annotations, and with similar meaning as smtlib's
      s-expressions (as used in the <code class="code">sexpr</code> function defined later).<br>
</div>
<br>
<h3 id="3_Termsleafconstructors">Terms leaf constructors</h3><br>

<pre><span id="VALvar"><span class="keyword">val</span> var</span> : <code class="type">?loc:location -> string -> t</code></pre>
<pre><span id="VALconst"><span class="keyword">val</span> const</span> : <code class="type">?loc:location -> string -> t</code></pre><div class="info ">
Variable and constant constructors. While in some languages
      they can distinguished at the laxical level (in tptp for instance),
      in most languages, it is an issue dependant on scoping rules,
      so terms parsed from an smtlib file will have all variables
      parsed as constants.<br>
</div>

<pre><span id="VALatom"><span class="keyword">val</span> atom</span> : <code class="type">?loc:location -> string -> t</code></pre>
<pre><span id="VALdistinct"><span class="keyword">val</span> distinct</span> : <code class="type">?loc:location -> string -> t</code></pre><div class="info ">
These functions are similar to constant building. Atoms are used
      for dimacs cnf parsing. <code class="code">distinct</code> is used in tptp to specify
      constants different from other constants, for instance the
      'distinct' "Apple" should be syntactically different from the "Apple"
      constant. Can be safely aliased to the <code class="code">const</code> function as the
      <code class="code">distinct</code> function is given strings already enclosed with quotes,
      so in the example above, <code class="code">const</code> would be called with <code class="code">"Apple"</code> as
      string argument, while <code class="code">distinct</code> would be called with the following
      string <code class="code">"\"Apple\""</code><br>
</div>

<pre><span id="VALint"><span class="keyword">val</span> int</span> : <code class="type">?loc:location -> string -> t</code></pre>
<pre><span id="VALrat"><span class="keyword">val</span> rat</span> : <code class="type">?loc:location -> string -> t</code></pre>
<pre><span id="VALreal"><span class="keyword">val</span> real</span> : <code class="type">?loc:location -> string -> t</code></pre>
<pre><span id="VALhexa"><span class="keyword">val</span> hexa</span> : <code class="type">?loc:location -> string -> t</code></pre>
<pre><span id="VALbinary"><span class="keyword">val</span> binary</span> : <code class="type">?loc:location -> string -> t</code></pre><div class="info ">
Constructors for words defined as numeric formats by the languages
      specifications. These also can be safely aliased to <code class="code">const</code>.<br>
</div>
<br>
<h3 id="3_Termconstructors">Term constructors</h3><br>

<pre><span id="VALcolon"><span class="keyword">val</span> colon</span> : <code class="type">?loc:location -> t -> t -> t</code></pre><div class="info ">
Representes juxtaposition of two terms, usually denoted "t : t'"
      in most languages, and mainly used to annotated terms with their
      supposed, or defined, type.<br>
</div>

<pre><span id="VALeq"><span class="keyword">val</span> eq</span> : <code class="type">?loc:location -> t -> t -> t</code></pre>
<pre><span id="VALnot_"><span class="keyword">val</span> not_</span> : <code class="type">?loc:location -> t -> t</code></pre>
<pre><span id="VALor_"><span class="keyword">val</span> or_</span> : <code class="type">?loc:location -> t list -> t</code></pre>
<pre><span id="VALand_"><span class="keyword">val</span> and_</span> : <code class="type">?loc:location -> t list -> t</code></pre>
<pre><span id="VALimply"><span class="keyword">val</span> imply</span> : <code class="type">?loc:location -> t -> t -> t</code></pre>
<pre><span id="VALequiv"><span class="keyword">val</span> equiv</span> : <code class="type">?loc:location -> t -> t -> t</code></pre><div class="info ">
Proposition construction functions. The conjunction and disjunction
      are n-ary instead of binary mostly because they are in smtlib (and
      that is subsumes the binary case).<br>
</div>

<pre><span id="VALapply"><span class="keyword">val</span> apply</span> : <code class="type">?loc:location -> t -> t list -> t</code></pre><div class="info ">
Application constructor, seen as higher order application
      rather than first-order application for the following reasons:
      being able to parse tptp's THF, having location attached
      to function symbols.<br>
</div>

<pre><span id="VALite"><span class="keyword">val</span> ite</span> : <code class="type">?loc:location -> t -> t -> t -> t</code></pre><div class="info ">
Conditional constructor, both for first-order terms and propositions.
      Used in the following schema: <code class="code">ite condition then_branch else_branch</code>.<br>
</div>

<pre><span id="VALpi"><span class="keyword">val</span> pi</span> : <code class="type">?loc:location -> t list -> t -> t</code></pre><div class="info ">
Binders constructors<br>
</div>

<pre><span id="VALletin"><span class="keyword">val</span> letin</span> : <code class="type">?loc:location -> t list -> t -> t</code></pre>
<pre><span id="VALforall"><span class="keyword">val</span> forall</span> : <code class="type">?loc:location -> t list -> t -> t</code></pre>
<pre><span id="VALexists"><span class="keyword">val</span> exists</span> : <code class="type">?loc:location -> t list -> t -> t</code></pre>
<pre><span id="VALlambda"><span class="keyword">val</span> lambda</span> : <code class="type">?loc:location -> t list -> t -> t</code></pre>
<pre><span id="VALchoice"><span class="keyword">val</span> choice</span> : <code class="type">?loc:location -> t list -> t -> t</code></pre>
<pre><span id="VALdescription"><span class="keyword">val</span> description</span> : <code class="type">?loc:location -> t list -> t -> t</code></pre><div class="info ">
Binders for variables. Takes a list of terms as first argument
      for simplicity, the lists will almost always be a list of variables,
      optionally typed using the <code class="code">colon</code> term constructor.<ul>
<li>Pi is the polymorphic type quantification, for instance
        the polymorphic identity function has type: "Pi alpha. alpha -&gt; alpha"</li>
<li>Letin is local binding, takes a list of equality of equivalences
        whose left hand-side is a variable.</li>
<li>Forall is universal quantification</li>
<li>Exists is existencial quantification</li>
<li>Lambda is used for function construction</li>
<li>Choice is the choice operator, also called indefinite description, or
        also epsilon terms, i.e "Choice x. p(x)" is one "x" such that "p(x)"
        is true.</li>
<li>Description is the definite description, i.e "Description x. p(x)"
        is the <b>only</b> "x" that satisfies p.</li>
</ul>
<br>
</div>
<br>
<h3 id="3_Typeconstructors">Type constructors</h3><br>

<pre><span id="VALarrow"><span class="keyword">val</span> arrow</span> : <code class="type">?loc:location -> t -> t -> t</code></pre><div class="info ">
Function type constructor, for curryfied functions. Functions
      that takes multiple arguments in first-order terms (and so
      naturally not curryfied) will take a product as only argument
      (see the following <code class="code">product</code> function).<br>
</div>

<pre><span id="VALproduct"><span class="keyword">val</span> product</span> : <code class="type">?loc:location -> t -> t -> t</code></pre><div class="info ">
Product type constructor, used for instance in the types of
      functions that takes multiple arguments in a non-curry way.<br>
</div>

<pre><span id="VALunion"><span class="keyword">val</span> union</span> : <code class="type">?loc:location -> t -> t -> t</code></pre><div class="info ">
Union type constructor, currently used in tptp's THF format.<br>
</div>

<pre><span id="VALsubtype"><span class="keyword">val</span> subtype</span> : <code class="type">?loc:location -> t -> t -> t</code></pre><div class="info ">
Subtype relation for types.<br>
</div>
<br>
<h3 id="3_Specialconstructions">Special constructions</h3><br>

<pre><span id="VALsequent"><span class="keyword">val</span> sequent</span> : <code class="type">?loc:location -> t list -> t list -> t</code></pre><div class="info ">
Sequents as terms<br>
</div>

<pre><span id="VALsexpr"><span class="keyword">val</span> sexpr</span> : <code class="type">?loc:location -> t list -> t</code></pre><div class="info ">
S-expressions (for smtlib attributes), should probably be related
      to the <code class="code">data_t</code> term.<br>
</div>
</body></html>