<html>
<head>
<link rel="stylesheet" href="style.css" type="text/css">
<meta content="text/html; charset=iso-8859-1" http-equiv="Content-Type">
<link rel="Start" href="index.html">
<link title="Index of types" rel=Appendix href="index_types.html">
<link title="Index of exceptions" rel=Appendix href="index_exceptions.html">
<link title="Index of values" rel=Appendix href="index_values.html">
<link title="Index of modules" rel=Appendix href="index_modules.html">
<link title="Index of module types" rel=Appendix href="index_module_types.html">
<link title="Term" rel="Chapter" href="Term.html">
<link title="Statement" rel="Chapter" href="Statement.html">
<link title="ParseLocation" rel="Chapter" href="ParseLocation.html">
<link title="Base_intf" rel="Chapter" href="Base_intf.html">
<link title="Term_intf" rel="Chapter" href="Term_intf.html">
<link title="Stmt_intf" rel="Chapter" href="Stmt_intf.html">
<link title="Lex_intf" rel="Chapter" href="Lex_intf.html">
<link title="Parse_intf" rel="Chapter" href="Parse_intf.html">
<link title="Location_intf" rel="Chapter" href="Location_intf.html">
<link title="Language_intf" rel="Chapter" href="Language_intf.html">
<link title="Dimacs" rel="Chapter" href="Dimacs.html">
<link title="Ast_dimacs" rel="Chapter" href="Ast_dimacs.html">
<link title="Smtlib" rel="Chapter" href="Smtlib.html">
<link title="Ast_smtlib" rel="Chapter" href="Ast_smtlib.html">
<link title="Zf" rel="Chapter" href="Zf.html">
<link title="Ast_zf" rel="Chapter" href="Ast_zf.html">
<link title="Tptp" rel="Chapter" href="Tptp.html">
<link title="Ast_tptp" rel="Chapter" href="Ast_tptp.html">
<link title="Logic" rel="Chapter" href="Logic.html"><title>Dolmen doc : Index of values</title>
</head>
<body>
<div class="navbar">&nbsp;<a class="up" href="index.html" title="Index">Up</a>
&nbsp;</div>
<h1>Index of values</h1>
<table>
<tr><td align="left"><br>A</td></tr>
<tr><td><a href="Ast_zf.Term.html#VALand_">and_</a> [<a href="Ast_zf.Term.html">Ast_zf.Term</a>]</td>
<td></td></tr>
<tr><td><a href="Term_intf.Logic.html#VALand_">and_</a> [<a href="Term_intf.Logic.html">Term_intf.Logic</a>]</td>
<td></td></tr>
<tr><td><a href="Ast_tptp.Term.html#VALand_t">and_t</a> [<a href="Ast_tptp.Term.html">Ast_tptp.Term</a>]</td>
<td></td></tr>
<tr><td><a href="Term_intf.Logic.html#VALand_t">and_t</a> [<a href="Term_intf.Logic.html">Term_intf.Logic</a>]</td>
<td></td></tr>
<tr><td><a href="Ast_tptp.Statement.html#VALannot">annot</a> [<a href="Ast_tptp.Statement.html">Ast_tptp.Statement</a>]</td>
<td></td></tr>
<tr><td><a href="Stmt_intf.Logic.html#VALannot">annot</a> [<a href="Stmt_intf.Logic.html">Stmt_intf.Logic</a>]</td>
<td><div class="info">
Constructors for attribute/annotations.
</div>
</td></tr>
<tr><td><a href="Ast_tptp.Term.html#VALapply">apply</a> [<a href="Ast_tptp.Term.html">Ast_tptp.Term</a>]</td>
<td></td></tr>
<tr><td><a href="Ast_zf.Term.html#VALapply">apply</a> [<a href="Ast_zf.Term.html">Ast_zf.Term</a>]</td>
<td></td></tr>
<tr><td><a href="Ast_smtlib.Term.html#VALapply">apply</a> [<a href="Ast_smtlib.Term.html">Ast_smtlib.Term</a>]</td>
<td><div class="info">
Application.
</div>
</td></tr>
<tr><td><a href="Term_intf.Logic.html#VALapply">apply</a> [<a href="Term_intf.Logic.html">Term_intf.Logic</a>]</td>
<td><div class="info">
Application constructor, seen as higher order application
      rather than first-order application for the following reasons:
      being able to parse tptp's THF, having location attached
      to function symbols.
</div>
</td></tr>
<tr><td><a href="Ast_tptp.Term.html#VALarrow">arrow</a> [<a href="Ast_tptp.Term.html">Ast_tptp.Term</a>]</td>
<td></td></tr>
<tr><td><a href="Ast_zf.Term.html#VALarrow">arrow</a> [<a href="Ast_zf.Term.html">Ast_zf.Term</a>]</td>
<td></td></tr>
<tr><td><a href="Term_intf.Logic.html#VALarrow">arrow</a> [<a href="Term_intf.Logic.html">Term_intf.Logic</a>]</td>
<td><div class="info">
Function type constructor, for curryfied functions.
</div>
</td></tr>
<tr><td><a href="Ast_smtlib.Statement.html#VALassert_">assert_</a> [<a href="Ast_smtlib.Statement.html">Ast_smtlib.Statement</a>]</td>
<td><div class="info">
Add a proposition to the current set of assertions.
</div>
</td></tr>
<tr><td><a href="Stmt_intf.Logic.html#VALassert_">assert_</a> [<a href="Stmt_intf.Logic.html">Stmt_intf.Logic</a>]</td>
<td><div class="info">
Add an assertion to the current set of assertions.
</div>
</td></tr>
<tr><td><a href="Ast_zf.Statement.html#VALassume">assume</a> [<a href="Ast_zf.Statement.html">Ast_zf.Statement</a>]</td>
<td></td></tr>
<tr><td><a href="Stmt_intf.Logic.html#VALassume">assume</a> [<a href="Stmt_intf.Logic.html">Stmt_intf.Logic</a>]</td>
<td><div class="info">
Adds an hypothesis.
</div>
</td></tr>
<tr><td><a href="Ast_dimacs.Term.html#VALatom">atom</a> [<a href="Ast_dimacs.Term.html">Ast_dimacs.Term</a>]</td>
<td><div class="info">
Make an atom from an non-zero integer.
</div>
</td></tr>
<tr><td><a href="Term_intf.Logic.html#VALatom">atom</a> [<a href="Term_intf.Logic.html">Term_intf.Logic</a>]</td>
<td><div class="info">
Atoms are used for dimacs cnf parsing.
</div>
</td></tr>
<tr><td><a href="Ast_zf.Statement.html#VALattr">attr</a> [<a href="Ast_zf.Statement.html">Ast_zf.Statement</a>]</td>
<td></td></tr>
<tr><td><a href="Ast_smtlib.Term.html#VALattr">attr</a> [<a href="Ast_smtlib.Term.html">Ast_smtlib.Term</a>]</td>
<td><div class="info">
Attach a list of attributes (also called annotations) to a term.
</div>
</td></tr>
<tr><td><a href="Stmt_intf.Logic.html#VALattr">attr</a> [<a href="Stmt_intf.Logic.html">Stmt_intf.Logic</a>]</td>
<td></td></tr>
<tr><td><a href="Term_intf.Logic.html#VALattr">attr</a> [<a href="Term_intf.Logic.html">Term_intf.Logic</a>]</td>
<td><div class="info">
Attach a list of attributes (also called annotations) to a term.
</div>
</td></tr>
<tr><td align="left"><br>B</td></tr>
<tr><td><a href="Ast_smtlib.Term.html#VALbinary">binary</a> [<a href="Ast_smtlib.Term.html">Ast_smtlib.Term</a>]</td>
<td><div class="info">
Constants lexically recognised as numbers in different formats.
</div>
</td></tr>
<tr><td><a href="Term_intf.Logic.html#VALbinary">binary</a> [<a href="Term_intf.Logic.html">Term_intf.Logic</a>]</td>
<td><div class="info">
Constructors for words defined as numeric formats by the languages
      specifications.
</div>
</td></tr>
<tr><td align="left"><br>C</td></tr>
<tr><td><a href="Ast_smtlib.Statement.html#VALcheck_sat">check_sat</a> [<a href="Ast_smtlib.Statement.html">Ast_smtlib.Statement</a>]</td>
<td><div class="info">
Solve the current set of assertions for satisfiability.
</div>
</td></tr>
<tr><td><a href="Stmt_intf.Logic.html#VALcheck_sat">check_sat</a> [<a href="Stmt_intf.Logic.html">Stmt_intf.Logic</a>]</td>
<td><div class="info">
Directive that instructs the prover to solve the current set of assertions.
</div>
</td></tr>
<tr><td><a href="Ast_tptp.Term.html#VALchoice">choice</a> [<a href="Ast_tptp.Term.html">Ast_tptp.Term</a>]</td>
<td></td></tr>
<tr><td><a href="Term_intf.Logic.html#VALchoice">choice</a> [<a href="Term_intf.Logic.html">Term_intf.Logic</a>]</td>
<td></td></tr>
<tr><td><a href="Ast_dimacs.Statement.html#VALclause">clause</a> [<a href="Ast_dimacs.Statement.html">Ast_dimacs.Statement</a>]</td>
<td><div class="info">
Make a clause from a list of literals.
</div>
</td></tr>
<tr><td><a href="Stmt_intf.Logic.html#VALclause">clause</a> [<a href="Stmt_intf.Logic.html">Stmt_intf.Logic</a>]</td>
<td><div class="info">
Add to the current set of assertions the given list of terms as a clause.
</div>
</td></tr>
<tr><td><a href="Ast_tptp.Statement.html#VALcnf">cnf</a> [<a href="Ast_tptp.Statement.html">Ast_tptp.Statement</a>]</td>
<td></td></tr>
<tr><td><a href="Stmt_intf.Logic.html#VALcnf">cnf</a> [<a href="Stmt_intf.Logic.html">Stmt_intf.Logic</a>]</td>
<td><div class="info">
TPTP directives.
</div>
</td></tr>
<tr><td><a href="Ast_tptp.Term.html#VALcolon">colon</a> [<a href="Ast_tptp.Term.html">Ast_tptp.Term</a>]</td>
<td></td></tr>
<tr><td><a href="Ast_zf.Term.html#VALcolon">colon</a> [<a href="Ast_zf.Term.html">Ast_zf.Term</a>]</td>
<td></td></tr>
<tr><td><a href="Ast_smtlib.Term.html#VALcolon">colon</a> [<a href="Ast_smtlib.Term.html">Ast_smtlib.Term</a>]</td>
<td><div class="info">
Juxtaposition of terms, used to annotate terms with their type.
</div>
</td></tr>
<tr><td><a href="Term_intf.Logic.html#VALcolon">colon</a> [<a href="Term_intf.Logic.html">Term_intf.Logic</a>]</td>
<td><div class="info">
Represents juxtaposition of two terms, usually denoted "t : t'"
      in most languages, and mainly used to annotated terms with their
      supposed, or defined, type.
</div>
</td></tr>
<tr><td><a href="ParseLocation.html#VALcombine">combine</a> [<a href="ParseLocation.html">ParseLocation</a>]</td>
<td><div class="info">
LogtkPosition that spans the two given positions.
</div>
</td></tr>
<tr><td><a href="ParseLocation.html#VALcombine_list">combine_list</a> [<a href="ParseLocation.html">ParseLocation</a>]</td>
<td><div class="info">
N-ary version of <a href="ParseLocation.html#VALcombine"><code class="code">ParseLocation.combine</code></a>.
</div>
</td></tr>
<tr><td><a href="Ast_tptp.Term.html#VALconst">const</a> [<a href="Ast_tptp.Term.html">Ast_tptp.Term</a>]</td>
<td></td></tr>
<tr><td><a href="Ast_zf.Term.html#VALconst">const</a> [<a href="Ast_zf.Term.html">Ast_zf.Term</a>]</td>
<td></td></tr>
<tr><td><a href="Ast_smtlib.Term.html#VALconst">const</a> [<a href="Ast_smtlib.Term.html">Ast_smtlib.Term</a>]</td>
<td><div class="info">
Constants, i.e non predefined symbols.
</div>
</td></tr>
<tr><td><a href="Term_intf.Logic.html#VALconst">const</a> [<a href="Term_intf.Logic.html">Term_intf.Logic</a>]</td>
<td><div class="info">
Variable and constant constructors.
</div>
</td></tr>
<tr><td align="left"><br>D</td></tr>
<tr><td><a href="Ast_zf.Statement.html#VALdata">data</a> [<a href="Ast_zf.Statement.html">Ast_zf.Statement</a>]</td>
<td></td></tr>
<tr><td><a href="Stmt_intf.Logic.html#VALdata">data</a> [<a href="Stmt_intf.Logic.html">Stmt_intf.Logic</a>]</td>
<td><div class="info">
Packs a list of mutually recursive inductive type declarations.
</div>
</td></tr>
<tr><td><a href="Ast_tptp.Term.html#VALdata_t">data_t</a> [<a href="Ast_tptp.Term.html">Ast_tptp.Term</a>]</td>
<td></td></tr>
<tr><td><a href="Term_intf.Logic.html#VALdata_t">data_t</a> [<a href="Term_intf.Logic.html">Term_intf.Logic</a>]</td>
<td><div class="info">
Term without semantic meaning, used for creating "data" terms.
</div>
</td></tr>
<tr><td><a href="Ast_zf.Statement.html#VALdecl">decl</a> [<a href="Ast_zf.Statement.html">Ast_zf.Statement</a>]</td>
<td></td></tr>
<tr><td><a href="Stmt_intf.Logic.html#VALdecl">decl</a> [<a href="Stmt_intf.Logic.html">Stmt_intf.Logic</a>]</td>
<td><div class="info">
Symbol declaration.
</div>
</td></tr>
<tr><td><a href="Ast_zf.Statement.html#VALdefinition">definition</a> [<a href="Ast_zf.Statement.html">Ast_zf.Statement</a>]</td>
<td></td></tr>
<tr><td><a href="Stmt_intf.Logic.html#VALdefinition">definition</a> [<a href="Stmt_intf.Logic.html">Stmt_intf.Logic</a>]</td>
<td><div class="info">
Symbol definition.
</div>
</td></tr>
<tr><td><a href="Ast_tptp.Term.html#VALdescription">description</a> [<a href="Ast_tptp.Term.html">Ast_tptp.Term</a>]</td>
<td></td></tr>
<tr><td><a href="Term_intf.Logic.html#VALdescription">description</a> [<a href="Term_intf.Logic.html">Term_intf.Logic</a>]</td>
<td><div class="info">
Binders for variables.
</div>
</td></tr>
<tr><td><a href="Ast_tptp.Term.html#VALdistinct">distinct</a> [<a href="Ast_tptp.Term.html">Ast_tptp.Term</a>]</td>
<td></td></tr>
<tr><td><a href="Term_intf.Logic.html#VALdistinct">distinct</a> [<a href="Term_intf.Logic.html">Term_intf.Logic</a>]</td>
<td><div class="info">
Used in tptp to specify constants different from other constants, for instance the
      'distinct' "Apple" should be syntactically different from the "Apple"
      constant.
</div>
</td></tr>
<tr><td align="left"><br>E</td></tr>
<tr><td><a href="Ast_zf.Term.html#VALeq">eq</a> [<a href="Ast_zf.Term.html">Ast_zf.Term</a>]</td>
<td></td></tr>
<tr><td><a href="Term_intf.Logic.html#VALeq">eq</a> [<a href="Term_intf.Logic.html">Term_intf.Logic</a>]</td>
<td></td></tr>
<tr><td><a href="ParseLocation.html#VALeq">eq</a> [<a href="ParseLocation.html">ParseLocation</a>]</td>
<td><div class="info">
Hash and equality
</div>
</td></tr>
<tr><td><a href="Ast_tptp.Term.html#VALeq_t">eq_t</a> [<a href="Ast_tptp.Term.html">Ast_tptp.Term</a>]</td>
<td></td></tr>
<tr><td><a href="Term_intf.Logic.html#VALeq_t">eq_t</a> [<a href="Term_intf.Logic.html">Term_intf.Logic</a>]</td>
<td></td></tr>
<tr><td><a href="Ast_zf.Term.html#VALequiv">equiv</a> [<a href="Ast_zf.Term.html">Ast_zf.Term</a>]</td>
<td></td></tr>
<tr><td><a href="Term_intf.Logic.html#VALequiv">equiv</a> [<a href="Term_intf.Logic.html">Term_intf.Logic</a>]</td>
<td><div class="info">
Proposition construction functions.
</div>
</td></tr>
<tr><td><a href="Ast_tptp.Term.html#VALequiv_t">equiv_t</a> [<a href="Ast_tptp.Term.html">Ast_tptp.Term</a>]</td>
<td></td></tr>
<tr><td><a href="Term_intf.Logic.html#VALequiv_t">equiv_t</a> [<a href="Term_intf.Logic.html">Term_intf.Logic</a>]</td>
<td></td></tr>
<tr><td><a href="Ast_tptp.Term.html#VALexists">exists</a> [<a href="Ast_tptp.Term.html">Ast_tptp.Term</a>]</td>
<td></td></tr>
<tr><td><a href="Ast_zf.Term.html#VALexists">exists</a> [<a href="Ast_zf.Term.html">Ast_zf.Term</a>]</td>
<td></td></tr>
<tr><td><a href="Ast_smtlib.Term.html#VALexists">exists</a> [<a href="Ast_smtlib.Term.html">Ast_smtlib.Term</a>]</td>
<td><div class="info">
Existencial quantification.
</div>
</td></tr>
<tr><td><a href="Term_intf.Logic.html#VALexists">exists</a> [<a href="Term_intf.Logic.html">Term_intf.Logic</a>]</td>
<td></td></tr>
<tr><td><a href="Ast_smtlib.Statement.html#VALexit">exit</a> [<a href="Ast_smtlib.Statement.html">Ast_smtlib.Statement</a>]</td>
<td><div class="info">
Exit the interactive loop.
</div>
</td></tr>
<tr><td><a href="Stmt_intf.Logic.html#VALexit">exit</a> [<a href="Stmt_intf.Logic.html">Stmt_intf.Logic</a>]</td>
<td><div class="info">
Exit directive (used in interactive mode).
</div>
</td></tr>
<tr><td align="left"><br>F</td></tr>
<tr><td><a href="Ast_zf.Term.html#VALfalse_">false_</a> [<a href="Ast_zf.Term.html">Ast_zf.Term</a>]</td>
<td></td></tr>
<tr><td><a href="Term_intf.Logic.html#VALfalse_">false_</a> [<a href="Term_intf.Logic.html">Term_intf.Logic</a>]</td>
<td><div class="info">
The constants for the true and false propositional constants.
</div>
</td></tr>
<tr><td><a href="Parse_intf.S.html#VALfile">file</a> [<a href="Parse_intf.S.html">Parse_intf.S</a>]</td>
<td><div class="info">
A function that parses an entire file, i.e until the end-of-file token,
      and return the list of parsed statements.
</div>
</td></tr>
<tr><td><a href="ParseLocation.html#VALfmt">fmt</a> [<a href="ParseLocation.html">ParseLocation</a>]</td>
<td></td></tr>
<tr><td><a href="ParseLocation.html#VALfmt_hint">fmt_hint</a> [<a href="ParseLocation.html">ParseLocation</a>]</td>
<td><div class="info">
Printing functions
</div>
</td></tr>
<tr><td><a href="Ast_tptp.Statement.html#VALfof">fof</a> [<a href="Ast_tptp.Statement.html">Ast_tptp.Statement</a>]</td>
<td></td></tr>
<tr><td><a href="Stmt_intf.Logic.html#VALfof">fof</a> [<a href="Stmt_intf.Logic.html">Stmt_intf.Logic</a>]</td>
<td></td></tr>
<tr><td><a href="Ast_tptp.Term.html#VALforall">forall</a> [<a href="Ast_tptp.Term.html">Ast_tptp.Term</a>]</td>
<td></td></tr>
<tr><td><a href="Ast_zf.Term.html#VALforall">forall</a> [<a href="Ast_zf.Term.html">Ast_zf.Term</a>]</td>
<td></td></tr>
<tr><td><a href="Ast_smtlib.Term.html#VALforall">forall</a> [<a href="Ast_smtlib.Term.html">Ast_smtlib.Term</a>]</td>
<td><div class="info">
Universal quantification.
</div>
</td></tr>
<tr><td><a href="Term_intf.Logic.html#VALforall">forall</a> [<a href="Term_intf.Logic.html">Term_intf.Logic</a>]</td>
<td></td></tr>
<tr><td><a href="Ast_smtlib.Statement.html#VALfun_decl">fun_decl</a> [<a href="Ast_smtlib.Statement.html">Ast_smtlib.Statement</a>]</td>
<td><div class="info">
Declares a new term symbol, and its type.
</div>
</td></tr>
<tr><td><a href="Stmt_intf.Logic.html#VALfun_decl">fun_decl</a> [<a href="Stmt_intf.Logic.html">Stmt_intf.Logic</a>]</td>
<td><div class="info">
Symbol declaration.
</div>
</td></tr>
<tr><td><a href="Ast_smtlib.Statement.html#VALfun_def">fun_def</a> [<a href="Ast_smtlib.Statement.html">Ast_smtlib.Statement</a>]</td>
<td><div class="info">
Defines a new function.
</div>
</td></tr>
<tr><td><a href="Stmt_intf.Logic.html#VALfun_def">fun_def</a> [<a href="Stmt_intf.Logic.html">Stmt_intf.Logic</a>]</td>
<td><div class="info">
Symbol definition.
</div>
</td></tr>
<tr><td><a href="Term.html#VALfun_ty">fun_ty</a> [<a href="Term.html">Term</a>]</td>
<td><div class="info">
Multi-arguments function type constructor.
</div>
</td></tr>
<tr><td align="left"><br>G</td></tr>
<tr><td><a href="Ast_smtlib.Statement.html#VALget_assertions">get_assertions</a> [<a href="Ast_smtlib.Statement.html">Ast_smtlib.Statement</a>]</td>
<td><div class="info">
Return the current set of assertions.
</div>
</td></tr>
<tr><td><a href="Stmt_intf.Logic.html#VALget_assertions">get_assertions</a> [<a href="Stmt_intf.Logic.html">Stmt_intf.Logic</a>]</td>
<td><div class="info">
Instructs the prover to print all current assertions.
</div>
</td></tr>
<tr><td><a href="Ast_smtlib.Statement.html#VALget_assignment">get_assignment</a> [<a href="Ast_smtlib.Statement.html">Ast_smtlib.Statement</a>]</td>
<td><div class="info">
Return the values of asserted propositions which have been labelled using
      the ":named" attribute.
</div>
</td></tr>
<tr><td><a href="Stmt_intf.Logic.html#VALget_assignment">get_assignment</a> [<a href="Stmt_intf.Logic.html">Stmt_intf.Logic</a>]</td>
<td><div class="info">
Instructs the prover to return truth assignemnt for labelled formulas (see smtlib manual
      for more information).
</div>
</td></tr>
<tr><td><a href="Ast_smtlib.Statement.html#VALget_info">get_info</a> [<a href="Ast_smtlib.Statement.html">Ast_smtlib.Statement</a>]</td>
<td><div class="info">
Get information (see smtlib manual).
</div>
</td></tr>
<tr><td><a href="Stmt_intf.Logic.html#VALget_info">get_info</a> [<a href="Stmt_intf.Logic.html">Stmt_intf.Logic</a>]</td>
<td></td></tr>
<tr><td><a href="Ast_smtlib.Statement.html#VALget_option">get_option</a> [<a href="Ast_smtlib.Statement.html">Ast_smtlib.Statement</a>]</td>
<td><div class="info">
Get the value of a prover option.
</div>
</td></tr>
<tr><td><a href="Stmt_intf.Logic.html#VALget_option">get_option</a> [<a href="Stmt_intf.Logic.html">Stmt_intf.Logic</a>]</td>
<td></td></tr>
<tr><td><a href="Ast_smtlib.Statement.html#VALget_proof">get_proof</a> [<a href="Ast_smtlib.Statement.html">Ast_smtlib.Statement</a>]</td>
<td><div class="info">
Return the proof of the lastest <code class="code">check_sat</code> if it returned unsat, else
      is undefined.
</div>
</td></tr>
<tr><td><a href="Stmt_intf.Logic.html#VALget_proof">get_proof</a> [<a href="Stmt_intf.Logic.html">Stmt_intf.Logic</a>]</td>
<td><div class="info">
If the last call to <code class="code">check_sat</code> returned UNSAT, then instruct the prover to return
      the proof of unsat.
</div>
</td></tr>
<tr><td><a href="Ast_smtlib.Statement.html#VALget_unsat_core">get_unsat_core</a> [<a href="Ast_smtlib.Statement.html">Ast_smtlib.Statement</a>]</td>
<td><div class="info">
Return the unsat core of the latest <code class="code">check_sat</code> if it returned unsat,
      else is undefined.
</div>
</td></tr>
<tr><td><a href="Stmt_intf.Logic.html#VALget_unsat_core">get_unsat_core</a> [<a href="Stmt_intf.Logic.html">Stmt_intf.Logic</a>]</td>
<td><div class="info">
If the last call to <code class="code">check_sat</code> returned UNSAT, then instruct the prover to return
      the unsat core of the unsatisfiability proof, i.e the smallest set of assertions
      needed to prove <code class="code">false</code>.
</div>
</td></tr>
<tr><td><a href="Ast_smtlib.Statement.html#VALget_value">get_value</a> [<a href="Ast_smtlib.Statement.html">Ast_smtlib.Statement</a>]</td>
<td><div class="info">
Return the value of the given terms in the current model of the solver.
</div>
</td></tr>
<tr><td><a href="Stmt_intf.Logic.html#VALget_value">get_value</a> [<a href="Stmt_intf.Logic.html">Stmt_intf.Logic</a>]</td>
<td><div class="info">
Instructs the prover to return the values of the given closed quantifier-free terms.
</div>
</td></tr>
<tr><td><a href="Ast_zf.Statement.html#VALgoal">goal</a> [<a href="Ast_zf.Statement.html">Ast_zf.Statement</a>]</td>
<td></td></tr>
<tr><td><a href="Stmt_intf.Logic.html#VALgoal">goal</a> [<a href="Stmt_intf.Logic.html">Stmt_intf.Logic</a>]</td>
<td><div class="info">
The goal, i.e the propositional formula to prove.
</div>
</td></tr>
<tr><td align="left"><br>H</td></tr>
<tr><td><a href="ParseLocation.html#VALhash">hash</a> [<a href="ParseLocation.html">ParseLocation</a>]</td>
<td></td></tr>
<tr><td><a href="Ast_smtlib.Term.html#VALhexa">hexa</a> [<a href="Ast_smtlib.Term.html">Ast_smtlib.Term</a>]</td>
<td></td></tr>
<tr><td><a href="Term_intf.Logic.html#VALhexa">hexa</a> [<a href="Term_intf.Logic.html">Term_intf.Logic</a>]</td>
<td></td></tr>
<tr><td align="left"><br>I</td></tr>
<tr><td><a href="Ast_tptp.Term.html#VALimplied_t">implied_t</a> [<a href="Ast_tptp.Term.html">Ast_tptp.Term</a>]</td>
<td></td></tr>
<tr><td><a href="Term_intf.Logic.html#VALimplied_t">implied_t</a> [<a href="Term_intf.Logic.html">Term_intf.Logic</a>]</td>
<td></td></tr>
<tr><td><a href="Ast_tptp.Term.html#VALimplies_t">implies_t</a> [<a href="Ast_tptp.Term.html">Ast_tptp.Term</a>]</td>
<td></td></tr>
<tr><td><a href="Term_intf.Logic.html#VALimplies_t">implies_t</a> [<a href="Term_intf.Logic.html">Term_intf.Logic</a>]</td>
<td><div class="info">
Standard logical connectives viewed as terms.
</div>
</td></tr>
<tr><td><a href="Ast_zf.Term.html#VALimply">imply</a> [<a href="Ast_zf.Term.html">Ast_zf.Term</a>]</td>
<td></td></tr>
<tr><td><a href="Term_intf.Logic.html#VALimply">imply</a> [<a href="Term_intf.Logic.html">Term_intf.Logic</a>]</td>
<td></td></tr>
<tr><td><a href="Ast_tptp.Statement.html#VALinclude_">include_</a> [<a href="Ast_tptp.Statement.html">Ast_tptp.Statement</a>]</td>
<td></td></tr>
<tr><td><a href="Stmt_intf.Logic.html#VALinclude_">include_</a> [<a href="Stmt_intf.Logic.html">Stmt_intf.Logic</a>]</td>
<td><div class="info">
Inlcude directive.
</div>
</td></tr>
<tr><td><a href="Ast_zf.Statement.html#VALinductive">inductive</a> [<a href="Ast_zf.Statement.html">Ast_zf.Statement</a>]</td>
<td></td></tr>
<tr><td><a href="Stmt_intf.Logic.html#VALinductive">inductive</a> [<a href="Stmt_intf.Logic.html">Stmt_intf.Logic</a>]</td>
<td><div class="info">
Inductive type definitions.
</div>
</td></tr>
<tr><td><a href="Parse_intf.S.Incremental.html#VALinput">input</a> [<a href="Parse_intf.S.Incremental.html">Parse_intf.S.Incremental</a>]</td>
<td></td></tr>
<tr><td><a href="Parse_intf.S.html#VALinput">input</a> [<a href="Parse_intf.S.html">Parse_intf.S</a>]</td>
<td><div class="info">
A function to parse a single statement.
</div>
</td></tr>
<tr><td><a href="Ast_tptp.Term.html#VALint">int</a> [<a href="Ast_tptp.Term.html">Ast_tptp.Term</a>]</td>
<td></td></tr>
<tr><td><a href="Ast_smtlib.Term.html#VALint">int</a> [<a href="Ast_smtlib.Term.html">Ast_smtlib.Term</a>]</td>
<td></td></tr>
<tr><td><a href="Term_intf.Logic.html#VALint">int</a> [<a href="Term_intf.Logic.html">Term_intf.Logic</a>]</td>
<td></td></tr>
<tr><td><a href="Ast_tptp.Term.html#VALite">ite</a> [<a href="Ast_tptp.Term.html">Ast_tptp.Term</a>]</td>
<td></td></tr>
<tr><td><a href="Term_intf.Logic.html#VALite">ite</a> [<a href="Term_intf.Logic.html">Term_intf.Logic</a>]</td>
<td><div class="info">
Conditional constructor, both for first-order terms and propositions.
</div>
</td></tr>
<tr><td align="left"><br>L</td></tr>
<tr><td><a href="Ast_tptp.Term.html#VALlambda">lambda</a> [<a href="Ast_tptp.Term.html">Ast_tptp.Term</a>]</td>
<td></td></tr>
<tr><td><a href="Term_intf.Logic.html#VALlambda">lambda</a> [<a href="Term_intf.Logic.html">Term_intf.Logic</a>]</td>
<td></td></tr>
<tr><td><a href="Ast_tptp.Term.html#VALletin">letin</a> [<a href="Ast_tptp.Term.html">Ast_tptp.Term</a>]</td>
<td></td></tr>
<tr><td><a href="Ast_zf.Term.html#VALletin">letin</a> [<a href="Ast_zf.Term.html">Ast_zf.Term</a>]</td>
<td></td></tr>
<tr><td><a href="Ast_smtlib.Term.html#VALletin">letin</a> [<a href="Ast_smtlib.Term.html">Ast_smtlib.Term</a>]</td>
<td><div class="info">
Local bindings.
</div>
</td></tr>
<tr><td><a href="Term_intf.Logic.html#VALletin">letin</a> [<a href="Term_intf.Logic.html">Term_intf.Logic</a>]</td>
<td></td></tr>
<tr><td align="left"><br>M</td></tr>
<tr><td><a href="ParseLocation.html#VALmk">mk</a> [<a href="ParseLocation.html">ParseLocation</a>]</td>
<td></td></tr>
<tr><td><a href="ParseLocation.html#VALmk_lexbuf">mk_lexbuf</a> [<a href="ParseLocation.html">ParseLocation</a>]</td>
<td><div class="info">
Reutnrs the lexbuf associetd with the given file or stdin,
    with the correct filename.
</div>
</td></tr>
<tr><td><a href="ParseLocation.html#VALmk_pair">mk_pair</a> [<a href="ParseLocation.html">ParseLocation</a>]</td>
<td></td></tr>
<tr><td><a href="Location_intf.S.html#VALmk_pos">mk_pos</a> [<a href="Location_intf.S.html">Location_intf.S</a>]</td>
<td><div class="info">
Make a position from two lewing positions.
</div>
</td></tr>
<tr><td><a href="ParseLocation.html#VALmk_pos">mk_pos</a> [<a href="ParseLocation.html">ParseLocation</a>]</td>
<td><div class="info">
Construction functions
</div>
</td></tr>
<tr><td align="left"><br>N</td></tr>
<tr><td><a href="Ast_tptp.Term.html#VALnand_t">nand_t</a> [<a href="Ast_tptp.Term.html">Ast_tptp.Term</a>]</td>
<td></td></tr>
<tr><td><a href="Term_intf.Logic.html#VALnand_t">nand_t</a> [<a href="Term_intf.Logic.html">Term_intf.Logic</a>]</td>
<td></td></tr>
<tr><td><a href="Ast_tptp.Term.html#VALneq_t">neq_t</a> [<a href="Ast_tptp.Term.html">Ast_tptp.Term</a>]</td>
<td></td></tr>
<tr><td><a href="Term_intf.Logic.html#VALneq_t">neq_t</a> [<a href="Term_intf.Logic.html">Term_intf.Logic</a>]</td>
<td><div class="info">
The terms representing equality and disequality, respectively.
</div>
</td></tr>
<tr><td><a href="Ast_tptp.Term.html#VALnor_t">nor_t</a> [<a href="Ast_tptp.Term.html">Ast_tptp.Term</a>]</td>
<td></td></tr>
<tr><td><a href="Term_intf.Logic.html#VALnor_t">nor_t</a> [<a href="Term_intf.Logic.html">Term_intf.Logic</a>]</td>
<td></td></tr>
<tr><td><a href="Ast_zf.Term.html#VALnot_">not_</a> [<a href="Ast_zf.Term.html">Ast_zf.Term</a>]</td>
<td></td></tr>
<tr><td><a href="Term_intf.Logic.html#VALnot_">not_</a> [<a href="Term_intf.Logic.html">Term_intf.Logic</a>]</td>
<td></td></tr>
<tr><td><a href="Ast_tptp.Term.html#VALnot_t">not_t</a> [<a href="Ast_tptp.Term.html">Ast_tptp.Term</a>]</td>
<td></td></tr>
<tr><td><a href="Term_intf.Logic.html#VALnot_t">not_t</a> [<a href="Term_intf.Logic.html">Term_intf.Logic</a>]</td>
<td></td></tr>
<tr><td align="left"><br>O</td></tr>
<tr><td><a href="Logic.Make.html#VALof_extension">of_extension</a> [<a href="Logic.Make.html">Logic.Make</a>]</td>
<td><div class="info">
These function take as argument either a language, or a filename,
      and return a triple: language, language file extension (starting with a dot), appropriate parsing module
</div>
</td></tr>
<tr><td><a href="Logic.Make.html#VALof_language">of_language</a> [<a href="Logic.Make.html">Logic.Make</a>]</td>
<td></td></tr>
<tr><td><a href="Location_intf.S.html#VALof_lexbuf">of_lexbuf</a> [<a href="Location_intf.S.html">Location_intf.S</a>]</td>
<td><div class="info">
Make a position using a lexbuf directly.
</div>
</td></tr>
<tr><td><a href="ParseLocation.html#VALof_lexbuf">of_lexbuf</a> [<a href="ParseLocation.html">ParseLocation</a>]</td>
<td><div class="info">
Recover a position from a lexbuf
</div>
</td></tr>
<tr><td><a href="Ast_zf.Term.html#VALor_">or_</a> [<a href="Ast_zf.Term.html">Ast_zf.Term</a>]</td>
<td></td></tr>
<tr><td><a href="Term_intf.Logic.html#VALor_">or_</a> [<a href="Term_intf.Logic.html">Term_intf.Logic</a>]</td>
<td></td></tr>
<tr><td><a href="Ast_tptp.Term.html#VALor_t">or_t</a> [<a href="Ast_tptp.Term.html">Ast_tptp.Term</a>]</td>
<td></td></tr>
<tr><td><a href="Term_intf.Logic.html#VALor_t">or_t</a> [<a href="Term_intf.Logic.html">Term_intf.Logic</a>]</td>
<td></td></tr>
<tr><td align="left"><br>P</td></tr>
<tr><td><a href="Logic.Make.html#VALparse_file">parse_file</a> [<a href="Logic.Make.html">Logic.Make</a>]</td>
<td><div class="info">
Given a filename, parse the file, and return the detected language
      together with the list of statements parsed.
</div>
</td></tr>
<tr><td><a href="Language_intf.S.html#VALparse_file">parse_file</a> [<a href="Language_intf.S.html">Language_intf.S</a>]</td>
<td><div class="info">
Parse the given file
</div>
</td></tr>
<tr><td><a href="Logic.Make.html#VALparse_input">parse_input</a> [<a href="Logic.Make.html">Logic.Make</a>]</td>
<td><div class="info">
Incremental parsing of either a file, or stdin.
</div>
</td></tr>
<tr><td><a href="Language_intf.S.html#VALparse_input">parse_input</a> [<a href="Language_intf.S.html">Language_intf.S</a>]</td>
<td><div class="info">
Incremental parsing.
</div>
</td></tr>
<tr><td><a href="Ast_tptp.Term.html#VALpi">pi</a> [<a href="Ast_tptp.Term.html">Ast_tptp.Term</a>]</td>
<td></td></tr>
<tr><td><a href="Ast_zf.Term.html#VALpi">pi</a> [<a href="Ast_zf.Term.html">Ast_zf.Term</a>]</td>
<td></td></tr>
<tr><td><a href="Term_intf.Logic.html#VALpi">pi</a> [<a href="Term_intf.Logic.html">Term_intf.Logic</a>]</td>
<td></td></tr>
<tr><td><a href="Ast_smtlib.Statement.html#VALpop">pop</a> [<a href="Ast_smtlib.Statement.html">Ast_smtlib.Statement</a>]</td>
<td><div class="info">
Pop the given number of level on the stack of assertions.
</div>
</td></tr>
<tr><td><a href="Stmt_intf.Logic.html#VALpop">pop</a> [<a href="Stmt_intf.Logic.html">Stmt_intf.Logic</a>]</td>
<td></td></tr>
<tr><td><a href="ParseLocation.html#VALpp">pp</a> [<a href="ParseLocation.html">ParseLocation</a>]</td>
<td></td></tr>
<tr><td><a href="Ast_tptp.Term.html#VALproduct">product</a> [<a href="Ast_tptp.Term.html">Ast_tptp.Term</a>]</td>
<td></td></tr>
<tr><td><a href="Term_intf.Logic.html#VALproduct">product</a> [<a href="Term_intf.Logic.html">Term_intf.Logic</a>]</td>
<td><div class="info">
Product type constructor, used for instance in the types of
      functions that takes multiple arguments in a non-curry way.
</div>
</td></tr>
<tr><td><a href="Ast_zf.Term.html#VALprop">prop</a> [<a href="Ast_zf.Term.html">Ast_zf.Term</a>]</td>
<td></td></tr>
<tr><td><a href="Term_intf.Logic.html#VALprop">prop</a> [<a href="Term_intf.Logic.html">Term_intf.Logic</a>]</td>
<td><div class="info">
The type of propositions.
</div>
</td></tr>
<tr><td><a href="Ast_smtlib.Statement.html#VALpush">push</a> [<a href="Ast_smtlib.Statement.html">Ast_smtlib.Statement</a>]</td>
<td><div class="info">
Push the given number of new level on the stack of assertions.
</div>
</td></tr>
<tr><td><a href="Stmt_intf.Logic.html#VALpush">push</a> [<a href="Stmt_intf.Logic.html">Stmt_intf.Logic</a>]</td>
<td><div class="info">
Directives for manipulating the set of assertions.
</div>
</td></tr>
<tr><td align="left"><br>R</td></tr>
<tr><td><a href="Ast_tptp.Term.html#VALrat">rat</a> [<a href="Ast_tptp.Term.html">Ast_tptp.Term</a>]</td>
<td></td></tr>
<tr><td><a href="Term_intf.Logic.html#VALrat">rat</a> [<a href="Term_intf.Logic.html">Term_intf.Logic</a>]</td>
<td></td></tr>
<tr><td><a href="Ast_tptp.Term.html#VALreal">real</a> [<a href="Ast_tptp.Term.html">Ast_tptp.Term</a>]</td>
<td></td></tr>
<tr><td><a href="Ast_smtlib.Term.html#VALreal">real</a> [<a href="Ast_smtlib.Term.html">Ast_smtlib.Term</a>]</td>
<td></td></tr>
<tr><td><a href="Term_intf.Logic.html#VALreal">real</a> [<a href="Term_intf.Logic.html">Term_intf.Logic</a>]</td>
<td></td></tr>
<tr><td><a href="Ast_zf.Statement.html#VALrewrite">rewrite</a> [<a href="Ast_zf.Statement.html">Ast_zf.Statement</a>]</td>
<td></td></tr>
<tr><td><a href="Stmt_intf.Logic.html#VALrewrite">rewrite</a> [<a href="Stmt_intf.Logic.html">Stmt_intf.Logic</a>]</td>
<td><div class="info">
Declare a rewrite rule, i.e a universally quantified equality or equivalence that
      can be oriented according to a specific ordering.
</div>
</td></tr>
<tr><td align="left"><br>S</td></tr>
<tr><td><a href="Ast_tptp.Term.html#VALsequent">sequent</a> [<a href="Ast_tptp.Term.html">Ast_tptp.Term</a>]</td>
<td></td></tr>
<tr><td><a href="Term_intf.Logic.html#VALsequent">sequent</a> [<a href="Term_intf.Logic.html">Term_intf.Logic</a>]</td>
<td><div class="info">
Sequents as terms
</div>
</td></tr>
<tr><td><a href="ParseLocation.html#VALset_file">set_file</a> [<a href="ParseLocation.html">ParseLocation</a>]</td>
<td><div class="info">
Change the file name used for positions in this lexbuf
</div>
</td></tr>
<tr><td><a href="Ast_smtlib.Statement.html#VALset_info">set_info</a> [<a href="Ast_smtlib.Statement.html">Ast_smtlib.Statement</a>]</td>
<td><div class="info">
Set information (see smtlib manual).
</div>
</td></tr>
<tr><td><a href="Stmt_intf.Logic.html#VALset_info">set_info</a> [<a href="Stmt_intf.Logic.html">Stmt_intf.Logic</a>]</td>
<td><div class="info">
Getter and setter for various informations (see smtlib manual).
</div>
</td></tr>
<tr><td><a href="Ast_smtlib.Statement.html#VALset_logic">set_logic</a> [<a href="Ast_smtlib.Statement.html">Ast_smtlib.Statement</a>]</td>
<td><div class="info">
Set the problem logic.
</div>
</td></tr>
<tr><td><a href="Stmt_intf.Logic.html#VALset_logic">set_logic</a> [<a href="Stmt_intf.Logic.html">Stmt_intf.Logic</a>]</td>
<td><div class="info">
Set the logic to be used for solving.
</div>
</td></tr>
<tr><td><a href="Ast_smtlib.Statement.html#VALset_option">set_option</a> [<a href="Ast_smtlib.Statement.html">Ast_smtlib.Statement</a>]</td>
<td><div class="info">
Set the value of a prover option.
</div>
</td></tr>
<tr><td><a href="Stmt_intf.Logic.html#VALset_option">set_option</a> [<a href="Stmt_intf.Logic.html">Stmt_intf.Logic</a>]</td>
<td><div class="info">
Getter and setter for prover options (see smtlib manual).
</div>
</td></tr>
<tr><td><a href="Ast_smtlib.Term.html#VALsexpr">sexpr</a> [<a href="Ast_smtlib.Term.html">Ast_smtlib.Term</a>]</td>
<td><div class="info">
S-expressions.
</div>
</td></tr>
<tr><td><a href="Term_intf.Logic.html#VALsexpr">sexpr</a> [<a href="Term_intf.Logic.html">Term_intf.Logic</a>]</td>
<td><div class="info">
S-expressions (for smtlib attributes), should probably be related
      to the <code class="code">data_t</code> term.
</div>
</td></tr>
<tr><td><a href="ParseLocation.html#VALsmaller">smaller</a> [<a href="ParseLocation.html">ParseLocation</a>]</td>
<td><div class="info">
<code class="code">smaller p1 p2</code> is true if <code class="code">p1</code> is included in <code class="code">p2</code>, ie
    <code class="code">p1</code> is a sub-location of <code class="code">p2</code> (interval inclusion)
</div>
</td></tr>
<tr><td><a href="Ast_tptp.Term.html#VALsubtype">subtype</a> [<a href="Ast_tptp.Term.html">Ast_tptp.Term</a>]</td>
<td></td></tr>
<tr><td><a href="Term_intf.Logic.html#VALsubtype">subtype</a> [<a href="Term_intf.Logic.html">Term_intf.Logic</a>]</td>
<td><div class="info">
Subtype relation for types.
</div>
</td></tr>
<tr><td align="left"><br>T</td></tr>
<tr><td><a href="Ast_zf.Term.html#VALtType">tType</a> [<a href="Ast_zf.Term.html">Ast_zf.Term</a>]</td>
<td></td></tr>
<tr><td><a href="Term_intf.Logic.html#VALtType">tType</a> [<a href="Term_intf.Logic.html">Term_intf.Logic</a>]</td>
<td><div class="info">
The type of types, defined as specific token by the Zipperposition format;
      in other languages, will be represented as a constant (the "$tType" constant
      in tptp for instance).
</div>
</td></tr>
<tr><td><a href="Ast_tptp.Statement.html#VALtff">tff</a> [<a href="Ast_tptp.Statement.html">Ast_tptp.Statement</a>]</td>
<td></td></tr>
<tr><td><a href="Stmt_intf.Logic.html#VALtff">tff</a> [<a href="Stmt_intf.Logic.html">Stmt_intf.Logic</a>]</td>
<td></td></tr>
<tr><td><a href="Ast_tptp.Statement.html#VALthf">thf</a> [<a href="Ast_tptp.Statement.html">Ast_tptp.Statement</a>]</td>
<td></td></tr>
<tr><td><a href="Stmt_intf.Logic.html#VALthf">thf</a> [<a href="Stmt_intf.Logic.html">Stmt_intf.Logic</a>]</td>
<td></td></tr>
<tr><td><a href="Lex_intf.S.html#VALtoken">token</a> [<a href="Lex_intf.S.html">Lex_intf.S</a>]</td>
<td><div class="info">
The function producing token from a lexbuf.
</div>
</td></tr>
<tr><td><a href="Ast_tptp.Statement.html#VALtpi">tpi</a> [<a href="Ast_tptp.Statement.html">Ast_tptp.Statement</a>]</td>
<td></td></tr>
<tr><td><a href="Stmt_intf.Logic.html#VALtpi">tpi</a> [<a href="Stmt_intf.Logic.html">Stmt_intf.Logic</a>]</td>
<td></td></tr>
<tr><td><a href="Ast_zf.Term.html#VALtrue_">true_</a> [<a href="Ast_zf.Term.html">Ast_zf.Term</a>]</td>
<td></td></tr>
<tr><td><a href="Term_intf.Logic.html#VALtrue_">true_</a> [<a href="Term_intf.Logic.html">Term_intf.Logic</a>]</td>
<td></td></tr>
<tr><td><a href="Ast_smtlib.Statement.html#VALtype_decl">type_decl</a> [<a href="Ast_smtlib.Statement.html">Ast_smtlib.Statement</a>]</td>
<td><div class="info">
Declares a new type constructor with given arity.
</div>
</td></tr>
<tr><td><a href="Stmt_intf.Logic.html#VALtype_decl">type_decl</a> [<a href="Stmt_intf.Logic.html">Stmt_intf.Logic</a>]</td>
<td><div class="info">
Type declaration.
</div>
</td></tr>
<tr><td><a href="Ast_smtlib.Statement.html#VALtype_def">type_def</a> [<a href="Ast_smtlib.Statement.html">Ast_smtlib.Statement</a>]</td>
<td><div class="info">
Defines an alias for types.
</div>
</td></tr>
<tr><td><a href="Stmt_intf.Logic.html#VALtype_def">type_def</a> [<a href="Stmt_intf.Logic.html">Stmt_intf.Logic</a>]</td>
<td><div class="info">
Type definition.
</div>
</td></tr>
<tr><td align="left"><br>U</td></tr>
<tr><td><a href="Ast_tptp.Term.html#VALunion">union</a> [<a href="Ast_tptp.Term.html">Ast_tptp.Term</a>]</td>
<td></td></tr>
<tr><td><a href="Term_intf.Logic.html#VALunion">union</a> [<a href="Term_intf.Logic.html">Term_intf.Logic</a>]</td>
<td><div class="info">
Union type constructor, currently used in tptp's THF format.
</div>
</td></tr>
<tr><td align="left"><br>V</td></tr>
<tr><td><a href="Ast_tptp.Term.html#VALvar">var</a> [<a href="Ast_tptp.Term.html">Ast_tptp.Term</a>]</td>
<td></td></tr>
<tr><td><a href="Term_intf.Logic.html#VALvar">var</a> [<a href="Term_intf.Logic.html">Term_intf.Logic</a>]</td>
<td></td></tr>
<tr><td align="left"><br>W</td></tr>
<tr><td><a href="Ast_zf.Term.html#VALwildcard">wildcard</a> [<a href="Ast_zf.Term.html">Ast_zf.Term</a>]</td>
<td></td></tr>
<tr><td><a href="Term_intf.Logic.html#VALwildcard">wildcard</a> [<a href="Term_intf.Logic.html">Term_intf.Logic</a>]</td>
<td><div class="info">
The wildcard term, usually used in place of type arguments
      to explicit polymorphic functions to not explicit types that
      can be inferred by the type-checker.
</div>
</td></tr>
<tr><td align="left"><br>X</td></tr>
<tr><td><a href="Ast_tptp.Term.html#VALxor_t">xor_t</a> [<a href="Ast_tptp.Term.html">Ast_tptp.Term</a>]</td>
<td></td></tr>
<tr><td><a href="Term_intf.Logic.html#VALxor_t">xor_t</a> [<a href="Term_intf.Logic.html">Term_intf.Logic</a>]</td>
<td></td></tr>
</table>
</body>
</html>